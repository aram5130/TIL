2021.09.27

------

## 3장

#### Array 배열

```c
#include <stdio.h>

int main(void)
{
    printf("Hello, World\n");
}
```

main이라는 함수는 프로그램의 시작점으로써 **실행 버튼을 클릭**하는 것과 같은 기능

printf는 출력을 담당하는 함수로, stdio.h 라는 라이브러리가 필요함.

studio.h는 헤더 파일로 C언어로 작성되어 있으면 파일명이 .h 로 끝나는 파일. 이 파일에는 printf 함수의 프로토타입이 있어서 Clang 컴파일러가 프로그램을 컴파일할때 printf가 무엇인지 알려주는 역할을 한다.



코드를 clang hello.c로 컴파일 하고 .a/.out 명령으로 프로그램을 실행할 때, 이 과정은 컴퓨터가 이해하는 0과1로 변환된 파일 a.out을 생성하여 실행.

a.out을 다른 이름으로 컴파일 하고 싶다면 아래와 같이 명령행 인자를 추가

```
clang -o hello hello.c
```

 CS50 라이브러리를 사용한 프로그램을 컴파일 할때는 clang에 또 하나의 프로그램 -lcs50이 필요함.

```
clang -o hello hello.c -lcs50
```

clang에세 CS50 라이브러리에 있는 모든 0과 1을 이곳에 연결하라는 의미.

더 간단하게는 make 프로그램을 이용하여 모든 컴파일 과정을 자동으로 처리할 수 있다.

make나 clang을 사용해서 프로그램을 실핼할 때 네 단계를 거친다.

1. 전처리
2. 컴파일링
3. 어셈블링
4. 링킹



1. 전처리(Precompile)

   컴파일의 첫 번째 단계는 **전처리**로 전처리기에 의해 수행된다.

   #으로 시작되는 C소스 코드는 전처리기에게 **실질적인 컴파일이 이루어지기 전에 무언가를 실행**하도록 알려준다.

   ex) #include는 전처리기에게 다른 파일의 내용을 포함 시키라고 알려주는 역할을 한다. 프로그램의 소스 코드에 #include와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 이 파일은 여전히 C소스 코드 형태이며, stdio.h 파일의 내용이 #include 부분에 포함된다.

2. 컴파일(Compile)

   전처리기가 전처리한 소스 코드를 생성하고 그 다음 단계로 컴파일을 한다. 컴파일러라고 불리는 프로그램은 C코드를 어셈블리라는 저수준의 프로그래밍 언어로 컴파일한다.

   어셈블리는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있다. C코드를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어줌.

3. 어셈블(Assemble)

   소스 코드가 어셈블리 코드로 변한되면, 어셈블리 코드를 오브젝트 코드로 변환 시킴. 컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꿔주는 작업이다. 소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한개라면, 컴파일 작업은 여기서 끝나지만 그렇지 않은 경우에는 링크라고 불리는 단계가 추가된다.

4. 링크(Link)

   프로그램이 여러개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 할 때, 링크라는 컴파일의 마지막 단계를 필요로 한다, 링커는 여러개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다.

   ex) 컴파일 하는 도안 CS50 라이브러리를 링크하면 오브젝트 코드는 Getlnt( )나 GetString( ) 같은 함수를 어떻게 실행할지 알 수 있게 된다.

위의 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성된다.





2021.09.28

------

#### 버그

**버그(bug)**는 코드에 들어있는 오류. 버그로 인해 프로그램의 실행에 실패하거나 프로그래머가 원하는 대로 동작하지 않게 된다. **디버깅(debugging)**은 **코드에 있는 버그를 식별하고 고치는 과정**이다. 프로그래머는 **디버거**라고 부르는 프로그램을 사용하여 디버깅을 하게 된다.

디버깅의 기본

프로그램은 일반적으로 인간보다 빠르게 연산하기 때문에, 단순히 프로그램을 실행시켜보는 것만으로는 잘못된 부분을 찾아내기가 어렵다. 디버거는 프로그램의 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움이 된다. 멈춰진 지점에서 무슨 일이 일어나는지 확인할 수 있는데, 프로그램이 멈추는 특정 지점을 **중지점** 이라고 한다. 프로그래머가 프로그램을 한번에 한 행씩 실행할 수 있게 해주어 프로그램이 내리는 모든 결정들을 단계별로 확인할 수 있게 된다.

###### 예제 (라이브러리 미포함)

```c
int main(void)
{
    printf("Hello, world\n");
}
```

make 프로그램을 이용하여 컴파일하면 "implicitly declaring library function 'printf"라는 에러 메세지가 나타난다. 이런 에러 메세지를 이해하기 힘들다면, help50 프로그램을 붙여서 실행하면 다시 컴파일시 생기는 오류를 해석해준다.

```
help50 make 파일이름
```

문제의 원인은 printf 함수를 사용하기 위해서 stdio.h 라이브러리를 포함해야 한다는 것.

###### 예제(변수 횟수)

```c
#include <stdio.h>

int main(void)
{
    for (int i = 0; i <= 10; i++)
    {
        printf("#\n");
    }
}
```

#을 10개 출력하기 위해 작성한 것, 위 코드를 컴파일 하고 실행하면 에러는 발생하지 않지만, 의도한바와 달리 #이 11개 출력되는 것을 확인할 수 있다.

아래와 같이 변수 i를 출력, printf("i is now %i", i);

```c
#include <stdio.h>

int main(void)
{
    for (int i = 0; i <= 10; i++)	// i < 10로 수정
    {
        printf("i is now %i", i);
        printf("#\n");
    }
}
```

결과를 확인하면 i가 0에서 시작하기 째문에 for 루프의 i <= 10이라는 조건은 실제로 11번을 만족한다. 따라아서 이를 i < 10으로 수정해주면 의도한대로 #이 10번 출력된다.

##### debug50

CS50 IDE를 사용하면 debug50이라는 프로그램을 사용할 수 있는데, 소스 코드에 직접 브레이크 포인트를 지정하고 소스파일을 컴파일한 후에 "debug50 파일명"으로 실행하면, 오른쪽 패널을 통해서 변수의 값을 확인하거나 브레이크 포인트부터 한 줄씩 코드를 실행해 볼 수  있다.



#### 코드의 디자인

코드가 심미적으로 잘 작성되어 있는지 확인해야한다. 공백의 수나 줄바꿈과 같은 것들은 코드의 실행에 직접적으로 영향을 주지는 않지만 코드를 작성하는 사람들이 코드를 읽고 이해하는데 영향을 주기 때문입니다. 가독성이 떨어질 경우, 불필요한 오해를 없애고, 코드를 이해하는데 드는 시간적인 비용을 최소화 하기 위해.

```c
for (int i = 0; i <= 10; i++)
    {
        printf("#\n");
    }
```

```c
for (int i = 0; i <= 10; i++){
    printf("#\n");
}
```

```c
for (int i = 0; i <= 10; i++){ printf("#\n"); }
```



#### 

메모리

C에는 아래와 같은 여러 자료형이 있고, 각각의 자료형은 서로 다른 크기의 메모리를 차지한다. 컴퓨터 안에는 RAM 이라고 하는 물리적인 칩이 메모리 역할을 한다.

- bool: 불리언, 1바이트
- char: 문자, 1바이트
- int: 정수, 4바이트
- float: 실수, 4바이트
- long: (더 큰) 정수, 8바이트
- double: (더 큰) 실수, 8바이트
- string: 문자열, ?바이트

#### 배열

예시

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // scores
    int score1 = 72;
    int score2 = 73;
    int score3 = 33;
    
    //print average
    printf("Average: %i\n", (socore1 + socore2 + socore3) / 3);
}
```

위처럼 세 개의 점수를 저장하고 그 평균을 출력하는 프로그램이 있다고 한다면,

만일 점수의 개수가 더 많아질 경우 이 프로그램은 많은 부분을 수정해야한다.

이 때 활용할 수 있는 것이 배열의 개념인데, 배열은 같은 자료형의 데이터를 메모리상에 연이어 저장하고 이를 하나의 변수로 관리하기 위해서 사용한다.

위의 코드를 배열을 사용해서 작성하면 아래와 같이 바꿀 수 있다.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // scores
    int scores[3];
    scores[0] = 73;
    scores[1] = 73;
    scores[2] = 33;
    
    //print average
    printf("Average: %i\n", (socores[0] + socores[1] + socores[2]) / 3);
}
```

int scores[3]; 이라는 코드는 int 자료형을 가지는 크기 3의 배열을 scores 라는 이름으로 생성하겠다는 의미하며, 배열의 인덱스는 0부터 시작하기 때문에, scores의 인덱스는 0, 1, 2 세 개를 만들어줄 수 있다.

하지만 위와 같은 코드는 여전히 점수의 갯수가 바뀌는 상황이 발생할 경우 제약이 많다.



#### 전역 변수

scores 배열의 크기를 정해주는 N이라는 변수를 선언하여, N이 조정된 값(상수)이라면 그 값을 선언할 때 const를 앞에 붙여서 **전역 변수**, 즉 **코드 전반에 거쳐 바뀌지 않는 값**임을 지정해줄 수 있다. (전역 변수의 이름은 통상적으로 대문자로 표기 한다.)

```c
#include <cs50.h>
#include <stdio.h>

const int N = 3;

int main(void)
{
    // scores
    int scores[N];
    scores[0] = 73;
    scores[1] = 73;
    scores[2] = 33;
    
    //print average
    printf("Average: %i\n", (socores[0] + socores[1] + socores[2]) / N);
}
```

scores의 크기로 전역 변수를 선언하였기 때문에 점수 개수가 바뀌었을때 수정해야 하는 코드가 줄어들었지만 여전히 배열의 인덱스마다 점수를 지정해주어야 하는 불편함이 있다.



#### 배열의 동적 선언 및 저장

위의 코드에 루프와 함수를 선언하여 좀 더 동적인 프로그램을 작성할 수 있다.

```c
#include <cs50.h>
#include <stdio.h>

float average (int length, int array[]);

int main(void)
{
    // 사용자로부터 점수 갯수를 입력받는다.
    int n = get_int("Scores: ");
    
    //점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Scores %i", i+1); //+1을 추가해줌. 컴퓨터는 0부터 카운팅하기 때문에
    }
    
    //평균 출력
    printf("Average: %.1f\n", average(n,scores));
}

//평균을 계산하는 함수
float average (int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        suma += array[i];
    }
    return (float)sum / (float length;)
}
```

배열의 크기를 사용자에게 직접 입력 받고, 배열의 크기만큼 루프를 돌면서 각 인덱스에 해당하는 값을 역시 사용자에게 동적으로 입력 받아 저장한다. 그리고 average 라는 함수를 따로 선언하여 평균을 구한다.

average 함수는 length 와 array[], 즉 배열의 길이와 배열을 입력으로 받고, 함수 안에서는 배열의 길이만큼 루프를 돌면서 값의 합을 구하고 최종적으로 평균값을 반환한다.



2021.09.30

------

#### 문자열과 배열

문자열(string) 자료형의 데이터는 문자(char) 자료형의 데이터들의 배열이다. **string s = “HI!”;** 과 같이 문자열 s가 정의되어 있다고 한다면,  s는 문자의 배열이기 때문에 메모리상에 아래와 같이 저장되고, 인덱스로 각 문자에 접근할 수 있다.

|  H   |  I   |  !   |  \0  |
| :--: | :--: | :--: | :--: |
| s[0] | s[1] | s[2] | s[3] |

가장 끝의 **‘\0’**은 문자열의 끝을 나타내는 널 종단 문자.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string names[4];
    
    names[0] = "EMMA";
    names[1] = "RODRIGO";
    names[2] = "BRIAN";
    names[3] = "DAVID";

    printf("%s\n", names[0]);
    printf("%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3]);
}

```

ames라는 문자열 형식의 배열에 네 개의 이름이 저장되어있다고 한다면, 첫 번째 printf에서는 names의 첫번째 인덱스의 값, 즉 “EMMA”를 출력.

두 번째 printf에서는 형식 지정자가 %s가 아닌 %c로 설정되어 있음을 확인할 수 있다. 따라서 출력하는 것은 문자열이 아닌 문자로, 각 이름의 두번째 문자를 출력한다. names[0] [1] 과 같이 2차원 배열을 통해 접근할 수 있다. 즉, names[0] [1]는 names의 첫 번째 값, “EMMA”라는 문자열에서, 그 두번째 값, ‘M’ 이라는 문자를 의미.

|      E       |      M       |      M       |      A       |      \0      |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| names[0] [0] | names[0] [1] | names[0] [2] | names[0] [3] | names[0] [4] |



#### 문자열의 활용

- 문자열의 길이 및 탐색

  ```c
  #include <cs50.h>
  #include <stdio.h>
  #include <string.h>
  
  int main(void)
  {
      string s = get_string("Input: ");
      printf("Output:\n");
      for (int i = 0, n = strlen(s); i < n; i++)
      {
          printf("%c\n", s[i]);
      }
  }
  ```

  strlen은 문자열의 길이를 알려주는 합수로, string.h 라이브러리 안에 포함되어있다.

  위의 코드에서는 n이라는 변수에 문자열 s의 길이를 저장하고, 해당 길이 만큼만 for 루프를 순환한다. 일일이 널 종단 문자를 검사하는 것보다 훨씬 효율적이다.

- 문자열의 탐색 및 수정

  아래와 같이 사용자로부터 문자열을 입력받아 대문자로 바꿔주는 프로그램을 작성할 수 있다.

  ```c
  #include <cs50.h>
  #include <stdio.h>
  #include <string.h>
  
  int main(void)
  {
      strign s = get_string("Before: ");
      printf("After: ");
      for (int i = 0, n = strlen(s); i < n; i++)
      {
          if (s[i] >= 'a' && s[i] <='z')
          {
              printf("%c", s[i] -32);
          }
          else
          {
              printf("%c", s[i]);
          }
      }
      printf("\n");
  }
  ```

  1. 사용자로부터 입력받을 문자를 s라는 변수에 저장.

  2. s의 길이만크 for 루프를 돌면서, 각 인덱스에 해당하는 문자가 'a'보다 크고 'z'보다 작은지 검사한다. 즉, 소문자인지 검사하는 것과 동일

     문자의 대소비교가 가능한 이유는 ASCII값, 문자가 정의되는 ASCII 코드 상에서 숫자값으로 비교할 수 있기 때문이다.

     알파벳 ASCII값을 살펴보면 알파벳의 소문자, 대문자는 32씩 차이가 나는 것을 확인할 수 있다. 소문자인 경우 그 값에서 32를 빼고 '문자'형태로 출력하면 대문자가 출력된다.

  동일한 작업을 수행하는 함수가 ctype 라이브러리에 toupper( ) 이라는 함수로 정의 되어 있다. ctype 라이브러리를 이용하면 간단하게 대문자 변환 프로그램을 작성할 수 있다.

  ```c
  #include <cs50.h>
  #include <ctype.h>
  #include <stdio.h>
  #include <string.h>
  
  int main(void)
  {
      string s = get_string("Before: ");
      printf("After:  ");
      for (int i = 0, n = strlen(s); i < n; i++)
      {
          printf("%c", toupper(s[i]));
      }
      printf("\n");
  }
  ```



#### 명령행 인자

main의 형태를 보면 하나의 함수라는 것을 알 수 있다. main( )안에 void 만 사용하는 것이 아닌 아래 코드 같이 argc, argv를 정의할 수 있다.

```c
#include <cs50.h>
#include <stdio.h>

int main (int argc, string argv[])
{
    if (argc == 2)
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
```

첫번째 변수 **argc**는 main 함수가 받게 될 입력의 개수를 나타낸다.

**argv[ ]**는 그 **입력이 포함되어 있는 배열**이다. 프로그램을 명령행에서 실행하므로, 입력은 문자열로 주어진다.

**argv[0]**는 기본적으로 **프로그램의 이름**으로 저장된다. 만약 하나의 입력이 더 주어진다면 argv[1]에 저장될 것이다.

예를 들어 위 프로그램 "arg.c"라는 이름으로 저장하고 컴파일 한 후, **"./argc"**로 실행하면 명령행 인자에 주어진 값이 프로그램 이름 하나밖에 없기 때문에 "hello, world"라는 값이 출력된다.

하지만 **“./argc David”**로 실행해보면 “hello, David”라는 값이 출력되는데, 명령행 인자에 David라는 값이 추가로 입력되었고, 따라서 argc 는 2, argv[1] 은 “David”가 되기 때문이다.














2021.10.09

------

## 5장

#### Memory 메모리

##### 16진수

컴퓨터 과학에서는 숫자를 10진수나 2진수 대신 **16진수(Hexadecimal)**로 표현하는 경우가 많은데, 컴퓨터에서 데이터를 처리하기 위해 16진수를 사용할 때 장점이 있기 때문이다. 16진수와 일상생활에서 사용하는 10진수를 비교해보면 차이를 알 수 있다. 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다.

- 10진수를 16진수로 바꾸기

  |   10진수   |     255      |    216     |     255     |
  | :--------: | :----------: | :--------: | :---------: |
  | **2진수**  |  1111 1111   | 1101 1000  |  1111 1111  |
  |            | f          f | d        8 | f         f |
  | **16진수** |     0xff     |    0xd8    |    0xff     |

  255 216 255를 2진수로 나타내면 위의 표와 같다. 2진수로 모든 데이터를 표현하기에는 너무 길어지기 때문에 16진수로 바꾸어보면 2<sup>4</sup>이 16이기 때문에 4bits씩 두 덩어리로 나누어 보면 0000부터 1111까지 16진수로 표현할 수 있다는 것을 알 수 있다.

  16진수에서 10부터 15까지를 표기하는 법은 10은 a, 11은 b, ...,15는 f를 대입하여 사용한다. 4bits씩 16진수로 변환 후 **0x**를 붙혀 뒤에 오는 문자들이 16진수임을 알려준다.

  

##### 16진수의 유효성

ASCII 코드에 의해 "A, B, C"는 10진수로 65, 66, 67에 해당한다. 컴퓨터는 10진수를 이해할 수 없으므로 2진수로 표현해보면 "01000001 01000010 01000011"이 된다. 컴퓨터가 처리할 수 있어야 하기 때문에 어쩔 수 없지만 그 길이가 너무 긴 것을 알 수 있다. 하지만 16진수로 표현하면 2진수로 표현했을 때 보다 훨씬 간단해진다. 또한 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현하기 때문에 **2개의 16진수는 1byte의 2진수로 변황**되기 때문에 정보를 표현하기 유용하다.

|        |     A     |     B     |     C     |
| :----: | :-------: | :-------: | :-------: |
| 10진수 |    65     |    66     |    67     |
| 2진수  | 0100 0001 | 0100 0010 | 0100 0011 |
|        | 4      1  | 4      2  | 4      3  |
| 16진수 |   0x41    |   0x42    |   0x43    |



##### 메모리 주소

정수형 변수 n에 50이라는 값을 저장하고 출력한다고 한다면, n이라는 값은 int 타입이므로, 아래 그림과 같이 컴퓨터의 메모리 어딘가에 **4바이트**만틈의 자리를 차지하며 저장되어 있을 것이다.

C에서는 변수의 **메모리상 주소**를 받기 위해 '&'이라는 연산자를 사용할 수 있다.

```c
#include <stdio.h>

int main(void)
{
	int n = 50;
	printf("%p\n", &n);
}
```

위와 같은 코드를 실행하면 '0xffe00b3adbc'와 같은 값을 얻을 수 있고, 이는 변수 n의 **16진법**으로 표현된 메모리의 주소이다. 반대로 '*'를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```

위의 코드는 먼저 **n의 주소**를 얻고, 또 다시 **그 주소에 해당하는 값**을 얻어와 출력한 것으로 '50'이라는 값이 출력된다.



##### 포인터

'*'연산자는 어떤 메모리 주소레 있는 값을 받아오게 하는 기능을 수행하며, **포인터 역할을 하는 변수**를 선언할 수도 있다.

```c
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}
```

위 코드를 보면 정수형 변수 n에 50이라는 값이 저장되어 있으며, ***p**라는 **포인터 변수**에 &n 이라는 값, 즉 **변수 n의 주소**를 저장한다. int *p에서 p앞에 있는 *는 이 변수가 보인터라는 의미이며, int 타입의 변수를 가리킨다는 의미를 갖는다. 따라서 첫 번째 printf문과 같이 포인터 p의 값, 즉 변수 **n의 주소를 출력**하거나, 두 번째 printf문과 같이 포인터 **n이 가르키는 변수의 값**, 즉 변수 n의 값을 출력할 수도 있다.



##### 문자열

지금까지 문자열을 저장하기 위해 CS50 라이브러리에 포함된 string 자료형을 사용했는데, 문자열은 결국 **문자의 배열**이고, s[0], s[1], s[2], ...와 같이 하나의 문자가 배열의 한 부분을 나타낸다. 가장 마지막의 \0은 0으로 이루어진 바이트로, **문자열의 끝**을 표시하는 약속이다.

|  E   |  M   |  M   |  A   |  \0  |
| :--: | :--: | :--: | :--: | :--: |
| s[0] | s[1] | s[2] | s[3] | s[4] |

여기서 **변수 s**는 이런 **문자열을 가르키는 포인터**가 된다. 더 자세하게는 문자열의 가장 첫번째 문자, 즉 주소 0x123에 있는 s[0]를 가르키게 된다.

```
typedef char *string
```

typedef는 새로운 자료형을, char *은 문자에 대한 포인터를, string은 자료형의 이름을 의미하며 아래 두 코드는 동일하게 동작한다.

1. string 자료형을 이용하여 "EMMA" 출력

   ```c
   #include <cs50.h>
   #include <stdio.h>
   
   int main(void)
   {
       string s = "EMMA";
       printf("%s\n", s);
   }
   ```

2. char 포인터를 이용하여 “EMMA” 출력

   ```c
   #include <stdio.h>
   
   int main(void)
   {
       char *s = "EMMA";
       printf("%s\n", s);
   }
   ```

두번째 코드의 char *s에서 s라는 변수는 문자에 대한 포인터가 되고, “EMMA”라는 문자열의 가장 첫 번째 값을 저장한다.



##### 문자열 비교

```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```

위 코드를 실행하면 s라는 포인터 값, 즉 "EMMA"라는 문자얄 가장 첫 값인 "E"에 해당하는 **메모리 주소**를 출력하게 된다. 아래의 코드들은 "EMMA"라는 문자들의 배열중에서 해당하는 숫자의 주소 값을 출력하게 된다. &s[0]는 “E”의 주소값을, &s[1]은 “M”의 주소값을, &s[2]은 “M”의 주소값을, &s[3]은 “A”의 주소값을 의미.

```c
printf("%p\n", &s[0]);		//"E"
printf("%p\n", &s[1]);		//"M"
printf("%p\n", &s[2]);		//"M"
printf("%p\n", &s[3]);		//"A"
```

가장 첫 번째 문자에 해당하는 **주소값을 하나씩 증가시키면** 바로 옆에 있는 문자의 값을 출력할 수 있다. 아래 코드는 E M M A를 순서대로 출력.

```c
printf("%c\n", *s);			//"E"
printf("%c\n", *(s+1));		//"M"
printf("%c\n", *(s+2));		//"M"
printf("%c\n", *(s+3));		//"A"
```



```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자로부터 s와 t 두 개의 문자열 입력받아 저장
    string s = get_string("s: ");
    string t = get_string("t: ");

    // 두 문자열을 비교 (각 문자들을 비교)
    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```












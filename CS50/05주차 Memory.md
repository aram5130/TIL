2021.10.09

------

## 5장

#### Memory 메모리

##### 16진수

컴퓨터 과학에서는 숫자를 10진수나 2진수 대신 **16진수(Hexadecimal)**로 표현하는 경우가 많은데, 컴퓨터에서 데이터를 처리하기 위해 16진수를 사용할 때 장점이 있기 때문이다. 16진수와 일상생활에서 사용하는 10진수를 비교해보면 차이를 알 수 있다. 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다.

- 10진수를 16진수로 바꾸기

  |   10진수   |     255      |    216     |     255     |
  | :--------: | :----------: | :--------: | :---------: |
  | **2진수**  |  1111 1111   | 1101 1000  |  1111 1111  |
  |            | f          f | d        8 | f         f |
  | **16진수** |     0xff     |    0xd8    |    0xff     |

  255 216 255를 2진수로 나타내면 위의 표와 같다. 2진수로 모든 데이터를 표현하기에는 너무 길어지기 때문에 16진수로 바꾸어보면 2<sup>4</sup>이 16이기 때문에 4bits씩 두 덩어리로 나누어 보면 0000부터 1111까지 16진수로 표현할 수 있다는 것을 알 수 있다.

  16진수에서 10부터 15까지를 표기하는 법은 10은 a, 11은 b, ...,15는 f를 대입하여 사용한다. 4bits씩 16진수로 변환 후 **0x**를 붙혀 뒤에 오는 문자들이 16진수임을 알려준다.

  

##### 16진수의 유효성

ASCII 코드에 의해 "A, B, C"는 10진수로 65, 66, 67에 해당한다. 컴퓨터는 10진수를 이해할 수 없으므로 2진수로 표현해보면 "01000001 01000010 01000011"이 된다. 컴퓨터가 처리할 수 있어야 하기 때문에 어쩔 수 없지만 그 길이가 너무 긴 것을 알 수 있다. 하지만 16진수로 표현하면 2진수로 표현했을 때 보다 훨씬 간단해진다. 또한 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현하기 때문에 **2개의 16진수는 1byte의 2진수로 변황**되기 때문에 정보를 표현하기 유용하다.

|        |     A     |     B     |     C     |
| :----: | :-------: | :-------: | :-------: |
| 10진수 |    65     |    66     |    67     |
| 2진수  | 0100 0001 | 0100 0010 | 0100 0011 |
|        | 4      1  | 4      2  | 4      3  |
| 16진수 |   0x41    |   0x42    |   0x43    |



##### 메모리 주소

정수형 변수 n에 50이라는 값을 저장하고 출력한다고 한다면, n이라는 값은 int 타입이므로, 아래 그림과 같이 컴퓨터의 메모리 어딘가에 **4바이트**만틈의 자리를 차지하며 저장되어 있을 것이다.

C에서는 변수의 **메모리상 주소**를 받기 위해 '&'이라는 연산자를 사용할 수 있다.

```c
#include <stdio.h>

int main(void)
{
	int n = 50;
	printf("%p\n", &n);
}
```

위와 같은 코드를 실행하면 '0xffe00b3adbc'와 같은 값을 얻을 수 있고, 이는 변수 n의 **16진법**으로 표현된 메모리의 주소이다. 반대로 '*'를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```

위의 코드는 먼저 **n의 주소**를 얻고, 또 다시 **그 주소에 해당하는 값**을 얻어와 출력한 것으로 '50'이라는 값이 출력된다.



##### 포인터

'*'연산자는 어떤 메모리 주소레 있는 값을 받아오게 하는 기능을 수행하며, **포인터 역할을 하는 변수**를 선언할 수도 있다.

```c
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}
```

위 코드를 보면 정수형 변수 n에 50이라는 값이 저장되어 있으며, ***p**라는 **포인터 변수**에 &n 이라는 값, 즉 **변수 n의 주소**를 저장한다. int *p에서 p앞에 있는 *는 이 변수가 보인터라는 의미이며, int 타입의 변수를 가리킨다는 의미를 갖는다. 따라서 첫 번째 printf문과 같이 포인터 p의 값, 즉 변수 **n의 주소를 출력**하거나, 두 번째 printf문과 같이 포인터 **n이 가르키는 변수의 값**, 즉 변수 n의 값을 출력할 수도 있다.



##### 문자열

지금까지 문자열을 저장하기 위해 CS50 라이브러리에 포함된 string 자료형을 사용했는데, 문자열은 결국 **문자의 배열**이고, s[0], s[1], s[2], ...와 같이 하나의 문자가 배열의 한 부분을 나타낸다. 가장 마지막의 \0은 0으로 이루어진 바이트로, **문자열의 끝**을 표시하는 약속이다.

|  E   |  M   |  M   |  A   |  \0  |
| :--: | :--: | :--: | :--: | :--: |
| s[0] | s[1] | s[2] | s[3] | s[4] |

여기서 **변수 s**는 이런 **문자열을 가르키는 포인터**가 된다. 더 자세하게는 문자열의 가장 첫번째 문자, 즉 주소 0x123에 있는 s[0]를 가르키게 된다.

```
typedef char *string
```

typedef는 새로운 자료형을, char *은 문자에 대한 포인터를, string은 자료형의 이름을 의미하며 아래 두 코드는 동일하게 동작한다.

1. string 자료형을 이용하여 "EMMA" 출력

   ```c
   #include <cs50.h>
   #include <stdio.h>
   
   int main(void)
   {
       string s = "EMMA";
       printf("%s\n", s);
   }
   ```

2. char 포인터를 이용하여 “EMMA” 출력

   ```c
   #include <stdio.h>
   
   int main(void)
   {
       char *s = "EMMA";
       printf("%s\n", s);
   }
   ```

두번째 코드의 char *s에서 s라는 변수는 문자에 대한 포인터가 되고, “EMMA”라는 문자열의 가장 첫 번째 값을 저장한다.



##### 문자열 비교

```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```

위 코드를 실행하면 s라는 포인터 값, 즉 "EMMA"라는 문자얄 가장 첫 값인 "E"에 해당하는 **메모리 주소**를 출력하게 된다. 아래의 코드들은 "EMMA"라는 문자들의 배열중에서 해당하는 숫자의 주소 값을 출력하게 된다. &s[0]는 “E”의 주소값을, &s[1]은 “M”의 주소값을, &s[2]은 “M”의 주소값을, &s[3]은 “A”의 주소값을 의미.

```c
printf("%p\n", &s[0]);		//"E"
printf("%p\n", &s[1]);		//"M"
printf("%p\n", &s[2]);		//"M"
printf("%p\n", &s[3]);		//"A"
```

가장 첫 번째 문자에 해당하는 **주소값을 하나씩 증가시키면** 바로 옆에 있는 문자의 값을 출력할 수 있다. 아래 코드는 E M M A를 순서대로 출력.

```c
printf("%c\n", *s);			//"E"
printf("%c\n", *(s+1));		//"M"
printf("%c\n", *(s+2));		//"M"
printf("%c\n", *(s+3));		//"A"
```



```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자로부터 s와 t 두 개의 문자열 입력받아 저장
    string s = get_string("s: ");
    string t = get_string("t: ");

    // 두 문자열을 비교 (각 문자들을 비교)
    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```



###### 문자열 복사

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;
    
    t[0] =toupper(t[0]);
    
    printf("S: $s\n", s);
    printf("t: %s\n", t);
}

```

사용자에게 입력값을 받아서 string s에 저장하고, string t를 s로 정의한다.

t의 첫 번째 문자를 toupper 함수를 이용하여 대문자로 바꾼다면(예시를 emma로 사용), s와 t 모두 "Emma"라고 출력 된다. 그 이유는 **s**라는 변수에는 "emma"라는 문자열이 아닌 그 문자열에 있는 **메모리의 주소가 저장**되기 때문이다. **string s**는 **char s**와 동일한 의미를 가지고 있다는 것을 생각한다면, t도 s와 동일한 주소를 가르키고 있고, t를 통한 수정은 s에도 그대로 반영된다.

만일 두 문자열을 실제로 메모리상에서 복사하려면 아래와 같이 **메모리 할당 함수**를 사용하면 된다.

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);
    
    for (int i = 0, n = strlen(s); i <n +1; i++)
    {
        t[i] = s[i];
    }
    
    t[0] = toupper(t[0]);
    
    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

**mallon**이라는 함수를 이용해서 t를 정의하여 정해진 크기 만큼 메모리를 할당한다.

즉, s 문자열의 길이에 **널 종단 문자(\n)**에 해당하는 **1**을 더한 만큼 메모리를 할당 하고, 루프를 돌면서 s 문자열 배열에 있는 문자 하나하나를 t 배열에 복사해준다.

이 코드를 컴파일하여 실행하고 입력값으로 "emma"를 주면 예상한 대로 s는 "emma", t는 "Emma"가 출력된다.

##### 메모리 누수

malloc 함수를 이용하여 메모리를 할당한 후에는 tree라는 함수를 이용하려 메모리를 해제해주어야 한다. 그렇지 않은 경우 메모리에 저장한 값은 **쓰레기 값**으로 남게 되어 메모리 요량의 낭비가 발생하게 된다. 이러한 현상을 **'메모리 누수'**라고 한다.

**'valgrind'**라는 프로그램을 사용하면 작성한 코드에서 메모리와 관련된 문제가 있는지 쉽게 확인할 수 있다.

```
help50 valgrind ./filename
```

위와 같은 명령어를 사용하면 filename 파일에 대한 valgrind의 검사 내용을 쉽게 확인할 수 있다.

```c
#include <stdlb.h>

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;		//x[9] = 0;
    			   // free(x);
}

int main(void)
{
    f();
    return 0;
}
```

f 함수를 살펴보면 포인터 x에는 int형의 사이즈(4바이트)의 10배에 해당하는 크기의 메모리인 40바이트를 할당한다. 그리고 x의 10번째 값으로 0을 할당한다.

main함수에서 f를 실행하게 되는데, 이 코드를 **valgrind**로 검사해보면 버퍼 오버플로우와 메모리 누수 두 가지 에러를 확인할 수 있다.

**버퍼 오버플로우** 는 x[10] = 0; 코드로 인해 발생하는데, 10개의 int형의 배열을 만들었는데 배열의 인덱스가 0부터 시작한다는 점을 생각한다면 인덱스 10은 11번째 인덱스레 접근하겠다는 의미가 되고, 이는 정의되지 않은 것이기 때문에 버퍼 오버플로우가 발생하는 것이다.

따라서, 이 오류는 0에서 9사이의 인덱스를 사용하면 해결할 수 있다.

또한 메모리 누수는 x 라는 포인터를 통해 할당한 메모리를 해제하기 위해 free(x)라는 코드를 추가해줌으로써 해결할 수 있다.

##### 메모리 교환, 스택, 힙

아래의 코드는 **swap**함수는 정수 a와 b를 입력받아 그 값을 바꾸는 일을 수행한다. main 함수에서는 x에 1, y에 2를 입력하고 swap 함수를 통해 그 두 값을 바꾸려고 한다.

```c
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;
    
    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a =b;
    b = tmp;
}
```

위의 코드를 컴파일하고 출력해보면 의도와는 다르게 swap함수를 거친 후에도 x와 y의 값이 바뀌지 않은채 그대로 출력되는 것을 알 수 있다. swap함수는 교확 작업을 제대로 수행하고 있지만, 문제는 교환하는 대상이 x, y 그 자체가 아닌 함수 내에서 새롭게 정의 된 a, b라는 것.

a, b는 각각 x와 y **값을 복제**하여 가지게 되는 것으로 **서로 다른 메모리 주소에 저장**된다.



메모리 안에는 데이터가 저장되는 구역이 나누어져 있는데, 머신 코드 영역에서는 프로그램이 실행될 때 프로그램이 컴파일된 바이너리가 저장되고, 글로벌 영역에서는 프로그램 안에서 저장된 전역 변수가 저장된다. 

**힙** 영역에서는 malloc으로 할당된 메모리의 데이터가 저장된다.

**스택**에서는 프로그램 내의 함수와 관련된 것들이 저장된다.

| machine code |
| :----------: |
|   globals    |
| heap<br />↓  |
|              |
| ↑<br />stack |

이를 바탕으로, 위의 코드를 보면 a, b, x, y, tmp 모두 **스택 영역**에 저장되지만 a와 x, b와 y는 그안에서도 서로 다른 위치에 저장되는 변수인 것. 따라서 a와 b를 바꾸는 것인 x와 y를 바꾸는 것에 아무런 영향을 주지 않는다.

a와 b를 **x와 y를 가르키는 포인터로 지정**하면 이 문제를 쉽게 해결할 수 있다.

```c
#include <stdio.h>

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```



##### 파일 쓰기

**머신 코드 영역**에는 프로그램이 실핼될 때 그 프로그램이 컴파일된 바이너리가 저장된다.

**글로벌 영역**에는 프로그램 안에서 저장된 전역 변수가 저장된다. **힙 영역**에는 malloc으로 할당된 메모리의 데이터가 저장된다. 그리고 **스택**에는 프로그램 내의 함수와 관련된 것들이 저장된다.



힙 영역에서는 **malloc에 의해 메모리가 더 할당될수록,** 점점 사용하는 메모리의 범위가 아래로 늘어나고 마찬가지고 스택 영역에서도 **함수가 더 많이 호출 될수록** 사용하는 메모리의 범위가 점점 위로 늘어난다. 제한된 메모리 용량에서는 기존의 값을 침범하는 상황도 발생한다. 이것을 **힙 오버플로우** 또는 **스택 오버플로우**라고 말한다.

###### 사용자에게 입력 받기

스택은 여태까지 많이 사용한 get_int나 get_string과 같은 함수에서 사용한다.

[get_int]

```c
#include <stdio.h>

int main(void)
{
    int x;
    printf("x: ");
    scanf("%i", &X);
    printf("x: %i\n", x);
}
```

[get_string]

```c
#include <stdio.h>

int main(void)
{
    char s[5];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}
```

위의 코드들에서 **scanf**라는 함수는 사용자들로부터 형식 지정자에 해당되는 값을 입력받아 저장하는 함수이다. get_int 코드에서 int x를 정의한 후레 scanf에 s가 아닌 **&s**로 그 주소를 입력해주는 부분을 유의해야한다.

scanf 함수의 변수가 실제로 스택 영역 안에 s가 저장된 주소로 찾아가서 사용자가 입력한 값을 저장하도록 하기 위함이며, get_string 코드에서는 scanf에 그대로 s를 입력해준다. 그 이유는 s를 크기가 5인 문자열, 즉 크기가 5인 char 자료형의 배열로 정의하였기 때문이다.

**clang** 컴파일러는 문자 배열의 이름을 포인터처럼 다룬다. 즉 scanf에 s라는 배열의 첫 바이트 주소를 넘겨주는 것이다.

###### 파일 쓰기

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *file = fopen("phonebook.csv", "a");
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");
    fprintf(file, "%s,%s\n", name, number);
    fclose(file);
}
```

**fopen**이라는 함수를 이용하면 파일을 FILE이라는 자료형으로 불러올 수 있다. fopen 함수의 첫번째 인자는 파일의 이름, 두번째 인자는 모드로 r은 읽기, w는 쓰기, a는 덧붙이기는 것을 의미.

사용자에게 name과 number라는 문자열을 입력 받고, 이를 **fprintf** 함수를 이용하여 printf에서처럼 파일에 직접 내용을 출력할 수 있다. 작업이 끝난 후에는 **fclose**함수로 파일에 대한 작업을 종료해줘야 한다.










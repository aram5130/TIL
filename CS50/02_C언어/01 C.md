2021.09.24

------

## 2장

#### C언어

C는 오래되고 전통적인 순수 텍스트 기반의 언어

```c
#include <stdio.h>
int main(void)					// '시작한다'는 의미를 가짐
{
    paintf("hello, world\n");     // '\n':줄바꿈 ';':문장을 마침
}
```

작성한 '소스코드'를 2진법으로 작성된 '머신코드'로 변환해야 컴퓨터가 이해할 수 있다. 이러한 작업을 컴파일러라는 프로그램이 수행한다.

source code -> compiler -> machine code

 terminal 창의 명령어 프롬프트에서 "$" 기호 옆으로 명령어를 입력한다.

1. clang 파일명 : 파일의 코드를 컴파일 하라는 의미.

2. 컴파일하게 되면 a.out 이라는 파일이 생성됨 (2진법으로 변경한 파일)

3. ./a.out 이라는 명령어를 실행하면 컴퓨터가 현재 디렉토리에 있는 a.out 이라는 프로그램을 실행하도록 해줌. (.마침표는 지금 있는 현재 폴더를 나타냄)

   <!--줄바꿈 시에 백슬래시가 원화 표시로 보이는 경우가 있는데 한글 윈도우에서는 원화 표시를 해주기 때문에 그렇게 나오는 것이므로 문제 없다.-->

- clang -o 컴파일파일명 기존.c파일명 : 파일명을 지정할 수 있다.
- ls : 현재 디렉토리의 파일을 확인



#### 문자열 string

- CS50 Sandbox에서 스크래치의 ask함수와 가장 비슷한 것은 **get_string 함수**이다

- String은 단어나 구절, 문장을 부르는 말 (숫자와는 다른 종류의 데이터)

```c
#include <cs50.h>
#include <stdio.h>
int main(void)					// '시작한다'는 의미를 가짐
{
    string answer = get_string("what's your name?\n"); /*answer는 원하는 변수로 정해도 무관함*/
    printf("hello, %s\n", answer); // %s는 문자열string의 s를 %뒤에 붙여서 인자를 받아준다.
}
```

1. 사용자 이름을 받아서 저장할 변수를 answer로 지정(변수의 이름은 자유)

   (c는 오래된 언어이기 때문에 변수가 저장하는 데이터의 종류를 정확하게 명시해야 한다.)

2. 저장하고자 하는 값의 종류가 문자열(string)이라는 것을 알려줘야 한다.

   이때 string을 **형식지정자**라고 한다. (컴퓨터에게 answer에 들어갈 값이 문자string이라고 알려주는 것)

3. =은 프로그래밍 언어에서 오른쪽에서 왼쪽으로 가는 화살표와 같은 기능.

   오른쪽에 있는 것을 왼쪽에 지정한다는 것으로 **할당 연산자**라고 한다.

   get_string 함수가 사용자의 이름을 반환하면 그 이름을 answer라는 변수에 저장 하는것.

4. 지정한 변수를 printf 함수로 출력한다. 이때,  printf("hello, answer"); 라고 입력하는 것이 아니라**printf("hello, %s\n", answer);** 라고 입력 해야한다.

   s는 문자열string의 s를 %뒤에 붙여서 인자를 받아주는 것으로 문자열을 받는것을 알려주는 것.

terminal 창에서 아래의 명령어를 입력하면 작성한 소스코드를 컴파일을 할 수 있다.

``` terminal
$ clang -o string stirng.c -lcs50
```

-o string 은 stirng.c를 string.out 이라는 머신코드로 저장하도록 하는 명령어.

-lcs50은 “link”라는 의미를 지닌 -l 이라는 인자에 추가로 포함한 “cs50” 파일을 합친 것이다. 이러한 복잡한 과정 대신, make 명령어를 통해 간단하게 컴파일을 수행할 수 있다.

``` terminal
$ make string
```

이렇게 작성한 코드를 컴파일하고 실행하면, 사용자에게 입력값을 받고 문장 내에 포함하여 출력하는 프로그램이 된다.



#### 숫자에 변수 지정

```c
//counter라는 변수에 숫자를 지정한 것
int counter = 0;

//counter의 변수값을 1씩 증가시키는 것
counter = counter + 1;
counter += 1;
```



#### 조건문

```c
if (x < y)
{
    printf("x is less than y/n");
}
```

- it의 괄호( ) 안에는 검사하고자 하는 **조건**이 들어가고, { } 안에는 조건을 만족할 경우 수행되는 작업을 넣는다.

  조건이 True 일 경우 "x is less than y"를 출력하도록 하는 것

- else를 이용하여 처음 조건이 아닌 경우에 다른 작업을 수행하도록 할 수도 있다.

  ```c
  if (x < y)
  {
      printf("x is less than y/n");
  }
  else
  {
      printf("x is not less than y/n");
  }
  ```

- 첫 번째 x < y 조건이 False일 경우, 증 x가 y보다 작지 않을 경우에는 "x is not less than y"를 출력하도록 하는 것

- 추가로 else if를 통해 다른 조건을 더 추가할 수도 있다.

  ```c
  if (x < y)
  {
      printf("x is less than y/n");
  }
  else if (x > y)
  {
      printf("x is not less than y/n");
  }
  else if (x == y)
  {
      printf("x is equal to y/n");
  }
  ```

- ==는 같다를 표현한다. (=는 **할당 연산자**이기 때문에 구분해주기 위해서 같다는 등호를 표시할 때는 ==를 사용한다.)

- 위에서 if(x < y), else if (x > y), else if (x == y) 세가지 조건문을 사용했는데, else if (x == y)는 굳이 사용할 필요가 없다. x가 y보다 작지도 크지도 않다면 같다는 가능성만 남기 때문에 else if (x == y) 가 아닌 else만 사용하여 간결하게 만들 수 있다.



#### 루프 loof

스크레치에서 사용한 것과 같이 while이나 for문을 사용해서 루프를 구현할 수 있다.

- while의 경우 아래의 코드와 같이 while ( ) 의 괄호 한에 조건을 넣고 { } 안에 수행할 작업을 포함시킨다.

  C에서 루프를 구현하고 싶을깨는 성립조건을 정해주어야 하는데, 답이 y, yes, true 또는 1로 나올 수 있는 질문을 해야한다. 5=5, 1<2 등을 사용할 수 있지만, 간단하게 true를 사용하면 된다.

- 특정 횟수만큼 작업을 수행하고 싶다면 아래와 같이 입력하도록 한다.

  *i는 50보다 작은가 -> 수행 -> i가 50보다 커지기 전까지 반복 -> i가 50보다 커지면 종료*

  ```c
  int i = 0;
  while (i < 50)
  {
      printf("hello, world\n");
      i = i + 1;
  }
  ```

  여기서 i는 정수의 값을 나타내는 약자로 많이 사용한다.

  **i = i + 1  /  i += 1  /   i++** 는 모두 같은 결과를 나타낸다. (i를 1씩 증가 시킴)

- 위처럼 변수를 따로 선언해도 되지만 for문을 사용하면 for ( ) 안에 각각에 해당하는 코드를 넣어서 간단하게 표현할 수도 있다.

  **( 변수 초기화; 변수조건; 변수증가 )**

  ```c
  for (int 1= 0; i < 50; i = i + 1)
  {
      printf("hello, world\n");
  }
  ```

  while문과 비교했을 때 코드가 훨씬 간단해진 것을 확인할 수 있다.

  

#### 데이터 타입

변수의 데이터 타입으로 사용할수 있는 것

- `bool` : 불리언 표현, ex) True, False, 1, 0, yes, no
- `char` : 문자 하나, ex) 'a', 'Z', '?'
- `string` : 문자열
- `int` : 특정 크기 또는 특정 비트까지의 정수 (예) 5, 28, -3, 0
- `long` : 더 큰 크기의 정수
- `float` : 부동소수점을 갖는 실수 (예) 3.14, 0.0, -28.56
- `double` : 부동소수점을 포함한 더 큰 실수

